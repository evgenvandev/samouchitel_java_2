# Как описать класс и подкласс?
Итак, описание класса начинается со слова `class`, после которого записывается имя класса. Соглашения *"Code Conventions"* рекомендуют начинать имя класса с заглавной буквы.

Перед словом `class` можно записать *модификаторы* класса (`class modifiers`). Это одно из слов `public`, `abstract`, `final`, `strictfp`. Перед именем вложенного класса можно поставить, кроме того, модификаторы `protected`, `private`, `static`. Модификаторы класса мы будем вводить по мере изучения языка.

Тело класса, в котором в любом порядке перечисляются поля, методы, конструкторы, вложенные классы и интерфейсы, заключается в фигурные скобки.

При описании поля указывается его тип, затем, через пробел, имя и, может быть, начальное значение после знака равенства, которое допустимо записать константным выражением. Всё это уже обсуждалось в *главе 1*.

Описание поля может начинаться с одного или нескольких необязательных модификаторов `public`, `protected`, `private`, `static`, `final`, `transient`, `volatile`. Если надо поставить несколько модификаторов, то перечислять их *JLS* рекомендует в указанном порядке, поскольку некоторые компиляторы требуют определённого порядка записи модификаторов. С модификаторами мы будем знакомиться по мере необходимости.

При описании метода указывается тип возвращаемого им значения или слово `void`, затем, через пробел, имя метода, потом, в скобках, список параметров. После этого в фигурных скобках расписывается выполняемый метод.

Описание метода может начинаться модификаторов `public`, `protected`, `private`, `abstract`, `static`, `final`, `synchronized`, `native`, `strictfp`. Мы будем вводить их по необходимости.

В списке параметров через запятую перечисляются тип и имя каждого параметра. Перед типом какого-либо параметра может стоять модификатор `final`. Такой параметр нельзя изменять внутри метода. Список параметров может отсутствовать, но скобки сохраняются.

Перед началом работы метода для каждого параметра выделяется ячейка оперативной памяти, в которую копируется значение параметра, заданное при обращении к методу. Такой способ называется передачей параметров *по значению*.

В _листинге 2.1_ показано, как можно оформить метод деления пополам для нахождения корня нелинейного уравнения из _листинга 1.5_.

### _Листинг 2.1. Нахождение корня нелинейного уравнения методом бисекции_
```java
/*
  Хабибуллин И.Ш. Самоучитель Java 2 - 2005
  Листинг 2.1. Нахождение корня нелинейного уравнения методом бисекции - стр. 78
*/
class Bisection2{
  private static double final EPS = 1e-8;  // Константа класса
  private double a = 0.0, b = 1.5, root;  // Закрытые поля экземпляра
  
  // Метод доступа к полю root
  public double getRoot(){
    return root;
  }
  
  private double f(double x){
    return x * x * x - 3 * x * x + 3;  // Можно написать что-то другое
  }
  
  // Параметров у метода нет - метод работает с полями экземпляра
  private void bisect(){
    // Локальная переменная - не поле
    double y = 0.0;
    do{
      root = 0.5 * (a + b);
      y = f(root);
      if(Math.abs(y) < EPS) break;  // Корень найден. Выходим из цикла
      
      // Если на концах отрезка [a; root] функция имеет разные знаки:
      if(f(a) * y < 0.0){
        // Значит, корень здесь, и мы переносим точку b в точку root
        b = root;
      } else {
        // В противном случае:
        // переносим точку a в точку root
        a = root;
      }
    } while(Math.abs(b - a) >= EPS);
  }
  
  // Точка входа в программу:
  public static void main(String[] args){
    Bisection2 b2 = new Bisection2();
    b2.bisect();
    // Обращаемся к корню через метод доступа
    System.out.println("x = " + b2.getRoot() + ", f() = " + b2.f(b2.getRoot()));
  }
}
```
В описании метода `f()` сохранён старый процедурный стиль: метод получает аргумент, обрабатывает его и возвращает результат. Описание метода `bisect()` выполнено в духе ООП: метод активен, он сам обращается к полям экземпляра `b2` и сам заносит результат в нужное поле. Метод `bisect()` - это внутренний механизм класса `Bisection2`, поэтому он закрыт (`private`).