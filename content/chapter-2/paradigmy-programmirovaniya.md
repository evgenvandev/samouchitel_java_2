## Объектно-ориентированное программирование в Java

Вся полувековая история программирования компьютеров, а может быть, и история всей науки - это попытка совладать 
со сложностью окружающего мира. Задачи, встающие перед программистами, становятся всё более громоздкими, информация, 
которую надо обработать, растёт как снежный ком. Ещё недавно обычными единицами измерения информации были килобайты и 
мегабайты, а сейчас уже говорят только о гигабайтах и терабайтах. Как только программисты предлагают более-менее удовлетворительное 
решение поставленных адач, тут же возникают новые, ещё более сложные задачи. Программисты придумывают новые методики, 
создают новые языки. За полвека появилось несколько сотен языков, предложено множество методов и стилей программирования. 
Некоторые методы и стили становятся общепринятыми и образуют на некоторое время так называемую *__парадигму программирования__*. 

## Парадигмы программирования

Первые, даже самые простые программы, написанные в машинных кодах, составляли сотни строк совершенно непонятного текста. Для 
упрощения и ускорения программирования придумали языки высокого уровня: FORTRAN, Algol и сотни других, возложив рутинные операции по 
созданию машинного кода на компилятор. Те же программы, переписанные на языках высокого уровня, стали гораздо понятнее и короче. 
Но жизнь потребовала решения более сложных задач, и программы снова увеличились в размерах, стали необозримыми. 

Возникла идея: оформить программу в виде нескольких, по возможности простых, процедур или функций, каждая из которых решает свою 
определённую задачу. Написать, откомпилировать и отладить небольшую процедуру можно легко и быстро. Затем остаётся только собрать 
все процедуры в нужном порядке в одну программу. Кроме того, один раз написанные процедуры можно затем использовать в других 
программах как строительные кирпичики. *__Процедурное программирование__* быстро стало парадигмой. Во все языки высокого уровня включили 
средства написания процедур и функций. Появилось множество библиотек процедур и функций на все случаи жизни. 

Встал вопрос о том, как выявить структуру программы, разбить программу на процедуры, какую часть кода выделить в отдельную процедуру, 
как сделать алгоритм решения задачи простым и наглядным, как удобнее связать процедуры между собой. Опытные программисты предложили 
свои рекомендации, названные *__структурным программированием__*. Структурное программирование оказалось удобным и стало парадигмой. 
Появились языки программирования, например Pascal, на которых удобно писать структурные программы. Более того, на них очень трудно 
написать неструктурные программы. 

Сложность стоящих перед программистами задач проявилась и тут: программы стали содержать сотни процедур и опять оказались необозримыми. 
"Кирпичики" стали слишком маленькими. Потребовался новый стиль программирования. 

В это же время обнаружилось, что удачная или неудачная структура исходных данных может сильно облегчить или усложнить их обработку. 
Одни исходные данные удобнее объединить в массив, для других больше подходит структура дерева или стека. Появилось множество исследований 
различных структур данных и рекомендаций по их применению. Никлаус Вирт, создатель языка Pascal, даже назвал одну из своих книг 
"Алгоритмы + структуры данных = программы". 

Возникла идея объединить исходные данные и все процедуры их обработки в один модуль. Эта идея *__модульного программирования__* быстро 
завоевала умы и на некоторое время стала парадигмой. Программы составлялись из отдельных модулей, содержащих десяток-другой процедур 
и функций. Эффективность таких программ тем выше, чем меньше модули зависят друг от друга. Автономность модулей позволяет создавать 
и библиотеки модулей, чтобы потом использовать их в качестве строительных блоков для других программ. 

Для того чтобы обеспечить максимальную независимость модулей друг от друга, надо чётко отделить процедуры, которые будут вызываться 
другими модулями, - _открытые_ (public) процедуры, от вспомогательных, которые обрабатывают данные, заключённые в этот модуль, - 
_закрытых_ (private) процедур. Первые перечисляются в отдельной части модуля - _интерфейсе_ (interface), вторые участвуют только в 
_реализации_ (implementation) модуля. Данные, занесённые в модуль, тоже делятся на открытые, указанные в интерфейсе и доступные 
для других модулей, и закрытые, доступные только для процедур того же модуля. В различных языках программирования это деление производится 
по-разному. В языке Turbo Pascal модуль специально делится на интерфейс и реализацию, в языке C интерфейс выносится в отдельные "головные" 
(header) файлы. В языке C++, кроме того, для описания интерфейса можно воспользоваться абстрактными классами. В языке Java есть специальная 
конструкция для описания интерфейсов, которая так и называется - _interface_, но можно написать и абстрактные классы. 

Так возникла идея о скрытии, _инкапсуляции_ (incapsulation) данных и методов их обработки. Подобные идеи периодически возникают в 
дизайне бытовой техники. То телевизоры испещряются кнопками и топорщатся ручками и движками на радость любознательному телезрителю, 
господствует "приборный" стиль, то вдруг всё куда-то пропадает, а на панели остаются только кнопка включения и ручка громкости. 
Любознательный телезритель, привыкший самостоятельно настраивать свой телевизор, берётся за отвёртку и лезет внутрь. 

Инкапсуляция, конечно, производится не для того, чтобы спрятать от другого модуля что-то любопытное. Здесь преследуются две основные 
цели. Первая - обеспечить безопасность использования модуля, вынести в интерфейс, сделать общедоступными только те методы обработки 
информации, которые не могут испортить или удалить исходные данные. Вторая цель - уменьшить сложность, скрыв от внешнего мира 
ненужные детали реализации. 

Опять возник вопрос: "Каким образом разбить программу на модули?" Тут кстати оказались методы решения старой задачи программирования - 
моделирования действий искусственных и природных объектов: роботов, станков с программным управлением, беспилотных самолётов, 
поведения людей, животных, растений, систем обеспечения жизнедеятельности, систем управления технологическими процессами. 

В самом деле, каждый объект - робот, автомобиль, человек - обладает определёнными характеристиками. Ими могут служить: вес, рост, 
максимальная скорость, угол поворота, грузоподъёмность, фамилия, возраст. Объект способен производить какие-то действия: перемещаться 
в пространстве, поворачиваться, поднимать, копать, расти или уменьшаться, есть, пить, рождаться и умирать, изменяя свои первоначальные 
характеристики. Удобно смоделировать объект в виде модуля. Его характеристики будут данными, постоянными или переменными, а действия - 
процедурами. 

Оказалось удобным сделать и обратное - разбить программу на модули, чтобы она превратилась в совокупность взаимодействующих объектов. 
Так возникло *__объектно-ориентированное программирование__* (object-oriented programming), сокращённо ООП (OOP) - современная парадигма 
программирования. 

В виде объектов можно представить совсем неожиданные понятия. Например, окно на экране дисплея - это объект, имеющий ширину `width` и 
высоту `height`, расположение на экране, описываемое обычно координатами `(x, y)` левого верхнего угла окна, а также шрифт, которым 
в окно выводится текст, скажем, Times New Roman, цвет фона `color`, несколько кнопок, полосы прокрутки и другие характеристики. Окно 
может перемещаться по экрану методом, описанным в процедуре `move()`, увеличиваться или уменьшаться в размерах методом `size()`, 
сворачиваться в ярлык методом `iconify()`, как-то реагировать на действия мыши и нажатия клавиш. Это полноценный объект! Кнопки, полосы 
прокрутки и прочие элементы окна - это тоже объекты со своими характеристиками и действиями: размерами, шрифтами, перемещениями. 

Разумеется, считать, что окно само "умеет" выполнять действия, а мы только даём ему поручения: "Свернись, развернись, передвинься", - это 
несколько неожиданный взгляд на вещи, но ведь сейчас можно подавать команды не только манипуляцией мышью и нажатием клавиш, но и голосом! 

Идея объектно-ориентированного программирования оказалась очень плодотворной и стала активно развиваться. Выяснилось, что удобно ставить 
задачу сразу в виде совокупности действующих объектов - возник *__объектно-ориентированный анализ__*, (object-oriented analysis, OOA). 
Решили проектировать сложные системы в виде объектов - появилось *__объектно-ориентированное проектирование__*, ООП (object-oriented design, OOD). 

Рассмотрим подробнее принципы объектно-ориентированного программирования. 